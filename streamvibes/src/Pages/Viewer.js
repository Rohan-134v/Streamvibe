import React, { useState, useRef, useEffect } from 'react';
import "./styles.css";
import { Link } from "react-router-dom";
import "./viewer.css"

const Viewer = () => {
  const [roomId, setRoomId] = useState('');
  const [comment, setComment] = useState('');
  const [comments, setComments] = useState([]);
  const [status, setStatus] = useState('Enter a Room ID and connect to stream.'); // User-friendly status
  const [errorMessage, setErrorMessage] = useState(''); // For displaying errors to the user
  const [yourWsId, setYourWsId] = useState(null); // To store the viewer's own WebSocket ID

  const videoRef = useRef(null);
  const ws = useRef(null);
  const peerConnection = useRef(null); // Single RTCPeerConnection for the streamer

  // Helper to send JSON messages via WebSocket
  const sendWebSocketMessage = (type, payload) => {
    if (ws.current?.readyState === WebSocket.OPEN) {
      const message = { type, ...payload, senderWsId: yourWsId }; // Always include senderWsId
      ws.current.send(JSON.stringify(message));
      console.log(`Sent WS message: ${type}`, message);
    } else {
      console.warn('WebSocket not open. Message not sent:', type, payload);
      setStatus('WebSocket not connected. Please try again.');
    }
  };

  // Function to initialize and configure RTCPeerConnection
  const initializePeerConnection = () => {
    if (peerConnection.current) {
      console.log('PeerConnection already initialized.');
      return peerConnection.current;
    }

    console.log('Initializing new RTCPeerConnection for viewer.');
    const pc = new RTCPeerConnection({
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }, // Google's public STUN server
      ],
    });

    // Handle incoming media tracks from the streamer
    pc.ontrack = (event) => {
      console.log('Received remote track:', event.track.kind);
      if (videoRef.current && event.streams && event.streams[0]) {
        // Attach the first stream to the video element
        videoRef.current.srcObject = event.streams[0];
        setStatus('Receiving stream...');
      }
    };

    // Handle ICE candidates generated by this viewer's PC
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        // Send candidate to the server to be relayed to the streamer
        sendWebSocketMessage('candidate', {
          roomId,
          candidate: event.candidate,
          targetWsId: 'streamer', // Assuming the streamer is the target
        });
      }
    };

    // Handle ICE connection state changes for debugging
    pc.oniceconnectionstatechange = () => {
      console.log(`Viewer PC ICE connection state: ${pc.iceConnectionState}`);
      if (pc.iceConnectionState === 'failed' || pc.iceConnectionstate === 'disconnected') {
        setStatus('Stream connection lost. Attempting to reconnect...');
        // Implement reconnection logic or prompt user
      } else if (pc.iceConnectionState === 'connected') {
        setStatus('Stream connected!');
      }
    };

    peerConnection.current = pc;
    return pc;
  };

  // Connects to the WebSocket server and initiates the viewer role
  const connectToStream = () => {
    if (!roomId.trim()) {
      setErrorMessage('Please enter a Room ID to connect.');
      return;
    }
    setErrorMessage(''); // Clear previous errors

    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      console.log('WebSocket already connected. Re-joining room.');
      sendWebSocketMessage('viewer', { roomId });
      return;
    }

    ws.current = new WebSocket('wss://ws-server-cgd7.onrender.com'); // Replace with your Render WebSocket URL

    ws.current.onopen = () => {
      console.log('WebSocket connected');
      setStatus('Connected to server. Requesting stream...');
      // Send initial message to identify as viewer and join room
      sendWebSocketMessage('viewer', { roomId });
    };

    ws.current.onmessage = async (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('Received WS message:', data.type, data);

        switch (data.type) {
          case 'connection-info': // Server sends this to provide own ws.id
            setYourWsId(data.yourWsId);
            console.log(`Viewer's WebSocket ID: ${data.yourWsId}`);
            break;

          case 'no-stream':
            setStatus('No active stream found in this room.');
            setErrorMessage('The streamer has not started broadcasting yet, or the room ID is incorrect.');
            break;

          case 'stream-active':
            setStatus('Stream is active. Waiting for streamer offer...');
            // Streamer should send an offer soon after this
            break;

          case 'stream-ended':
            setStatus('Stream ended by streamer.');
            setErrorMessage('The streamer has disconnected or ended the broadcast.');
            if (peerConnection.current) {
              peerConnection.current.close();
              peerConnection.current = null;
            }
            if (videoRef.current) {
              videoRef.current.srcObject = null;
            }
            break;

          case 'comment':
            // Server sends comments with 'viewerId' and 'message'
            setComments((prev) => [
              ...prev,
              {
                viewerId: data.viewerId?.trim() || 'Anonymous',
                message: data.message?.trim() || '',
              },
            ]);
            break;

          case 'offer':
            // Received an SDP offer from the streamer (via server)
            const pc = initializePeerConnection(); // Ensure PC is ready
            if (pc.remoteDescription?.type !== 'offer') {
              await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
              console.log('Received and set offer from streamer.');

              // Create and send an answer back to the streamer
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              sendWebSocketMessage('answer', {
                roomId,
                sdp: pc.localDescription,
                targetWsId: data.senderWsId, // Send answer back to the streamer's ID
              });
              setStatus('Sending answer to streamer...');
              console.log('Sent answer to streamer.');
            } else {
              console.warn('Already has remote offer description.');
            }
            break;

          case 'candidate':
            // Received an ICE candidate from the streamer (via server)
            const candidatePc = peerConnection.current;
            if (candidatePc) {
              try {
                await candidatePc.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('Added ICE candidate from streamer.');
              } catch (e) {
                console.error('Error adding received ICE candidate:', e);
              }
            } else {
              console.warn('No PeerConnection to add candidate to.');
            }
            break;

          case 'error':
            console.error('Server error:', data.message);
            setErrorMessage(`Server Error: ${data.message}`);
            setStatus('Server error occurred.');
            break;

          default:
            console.warn('Unknown message type received from server:', data.type);
        }
      } catch (error) {
        // This catch block is for JSON parsing errors. Binary data is handled by WebRTC.
        console.error('Error parsing WebSocket message as JSON:', error);
        setErrorMessage('Received malformed message from server.');
      }
    };

    ws.current.onclose = () => {
      console.warn('WebSocket closed');
      setStatus('Disconnected from server');
      setErrorMessage('WebSocket connection closed.');
      if (peerConnection.current) {
        peerConnection.current.close();
        peerConnection.current = null;
      }
      if (videoRef.current) {
        videoRef.current.srcObject = null;
      }
      setYourWsId(null);
    };

    ws.current.onerror = (err) => {
      console.error('WebSocket error:', err);
      setStatus('WebSocket error occurred');
      setErrorMessage('WebSocket connection error. Check console for details.');
    };
  };

  const sendComment = () => {
    if (!comment.trim()) {
      setErrorMessage('Comment cannot be empty.');
      return;
    }
    if (!ws.current || ws.current.readyState !== WebSocket.OPEN) {
      setErrorMessage('Not connected to stream. Cannot send comment.');
      return;
    }
    setErrorMessage('');
    // Send comment with viewerId (you might get this from authentication)
    // For now, using a placeholder or prompting the user for a name
    const viewerId = `Viewer-${yourWsId ? yourWsId.substring(0, 5) : Math.random().toString(36).substring(2, 7)}`;
    sendWebSocketMessage('comment', { roomId, viewerId, message: comment });
    setComments((prev) => [...prev, { viewerId, message: comment }]); // Optimistically add to local comments
    setComment('');
  };

  useEffect(() => {
    return () => {
      // Cleanup on component unmount
      if (ws.current) ws.current.close();
      if (peerConnection.current) peerConnection.current.close();
      if (videoRef.current) videoRef.current.srcObject = null;
    };
  }, []);

  return (
    <div>
      <nav className="navbar">
        <div className="logo">
          STREAM<span>VIBE</span>
        </div>
        <div className="nav-links">
          <Link to="/streamer">Home</Link>
          <Link to="/about">About</Link>
          <Link to="/contact">Contact</Link>
        </div>
      </nav>
      <section className='hero'>
        <div className="viewer-controls">
          <input
            type="text"
            placeholder="Enter Room ID"
            value={roomId}
            onChange={(e) => setRoomId(e.target.value)}
            disabled={ws.current?.readyState === WebSocket.OPEN} // Disable input if connected
          />
          <button onClick={connectToStream} disabled={ws.current?.readyState === WebSocket.OPEN}>
            Connect to Stream
          </button>
        </div>

        {status && <p className="status-message">{status}</p>}
        {errorMessage && <p className="error-message">{errorMessage}</p>}

        <div className="video-and-comments-container">
          <div className="video-player-container">
            <video id="video" ref={videoRef} autoPlay playsInline controls className="stream-video" />
          </div>

          <div className="comments-section">
            <h3>Comments</h3>
            <div className="comments-list">
              {comments.map((c, idx) => (
                <p key={idx}><strong>{c.viewerId}:</strong> {c.message}</p>
              ))}
            </div>
            <div className="comment-input-area">
              <input
                type="text"
                placeholder="Write a comment..."
                value={comment}
                onChange={(e) => setComment(e.target.value)}
                onKeyPress={(e) => { if (e.key === 'Enter') sendComment(); }}
              />
              <button onClick={sendComment}>Send</button>
            </div>
          </div>
        </div>
      </section>
      <footer>
        <div className="footer-content">
          <div className="footer-section">
            <h3>Quick Links</h3>
            <Link to="/home">Home</Link>
            <Link to="/about">About Us</Link>
            <Link to="/rules">Rules</Link>
            <Link to="/legacy">Legacy</Link>
            <Link to="/pricing">Pricing</Link>
            <Link to="/contact">Contact</Link>
          </div>
          <div className="footer-section">
            <h3>Legal</h3>
            <a href="#">Terms of Service</a>
            <a href="#">Privacy Policy</a>
          </div>
          <div className="footer-section">
            <h3>Connect</h3>
            <div className="social-links">
              <a href="#">
                <i className="fab fa-facebook"></i>
              </a>
              <a href="#">
                <i className="fab fa-twitter"></i>
              </a>
              <a href="#">
                <i className="fab fa-instagram"></i>
              </a>
            </div>
          </div>
        </div>
        <div className="footer-bottom">
          <p>&copy; 2024 STREAMVIBE. All rights reserved.</p>
        </div>
      </footer>
    </div>
  );
};

export default Viewer;
